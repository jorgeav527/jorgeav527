+++
title = "Python fundamentals for Data Science"
date = "2025-03-06T16:11:08-05:00"
cover = ""
description = 'Here is a complete guide to Python fundamentals for Data Science, starting with the basics of Python programming, iterators and generators, SQL with SQLite NoSQL with MongoDB, pandas and numpy, and how to make ETL and a EDA'
+++

## Referencias

- [Python Syntax - W3Schools](https://www.w3schools.com/python/python_syntax.asp)
- [SoloLearn - Python Courses](https://www.sololearn.com/en/)
- [CS50's Python Course - Harvard](https://cs50.harvard.edu/python/2022/)
- [freeCodeCamp Python Curriculum](https://www.freecodecamp.org/learn)
- [Learn Python in Y Minutes](https://learnxinyminutes.com/docs/python/)

## 1. Operaciones con numeros y flotantes

{{< code language="python" title="Numeros y flotantes" open="false" >}}
# Sumamos 1 m√°s 1 y mostramos el resultado
print(1+1)  # La salida ser√° 2

# Restamos 1 de 8 y mostramos el resultado
print(8-1)  # La salida ser√° 7

# Multiplicamos 10 por 2 y mostramos el resultado
print(10*2)  # La salida ser√° 20

# Divisi√≥n
# Dividimos 11 entre 4 y mostramos el resultado
print(11/4)  # La salida ser√° 2.75 (como n√∫mero decimal)

# Dividimos 11.0 entre 4.0 y mostramos el resultado
print(11.0/4.0)  # La salida tambi√©n ser√° 2.75 (como n√∫mero decimal)

# Modulo
# Calculamos el residuo de la divisi√≥n de 7 entre 3 y mostramos el resultado
print(7%3)  # La salida ser√° 1

# Exponentes
# En este espresi√≥n elevamos 2 a la cuarta potencia y mostramos el resultado
print(2**4)  # La salida ser√° 16

# PEMDAS
# realiza la adici√≥n antes de la multiplicaci√≥n, siguiendo la regla de PEMDAS.
print(1 + 3 * 2)    # => 7
print((1 + 3) * 2)  # => 8
{{< /code >}}

{{< details summary="Cual es el resultado de print(( (2 + 8 / 4 ** 2) * (3 - 1) ) % 5) ?">}}
  ```python
  resultado = ( (2 + 8 / 4 ** 2) * (3 - 1) ) % 5
  print(resultado)  # ¬øQu√© imprime?
  ```
{{< /details >}}

Por si no se acuerdan el acr√≥nimo PEMDAS se usa para recordar el orden de las operaciones aritm√©ticas:

1. Primero las operaciones dentro de los par√©ntesis.
2. Luego exponentes o potencias.
3. Luego multiplicaciones y divisiones de izquierda a derecha.
4. Y por √∫ltimo sumas y restas tambi√©n de izquierda a derecha.

## 2. Operaciones con boleanos

{{< code language="python" title="Boleanos" open="false" >}}
# Realizamos la operaci√≥n l√≥gica "and" entre True y False y mostramos el resultado
print(True and False)  # La salida ser√° False

# En esta operaci√≥n "and", ambos operandos deben ser True para que el resultado sea True.
# Como uno de los operandos es False, el resultado es False.

# Realizamos la operaci√≥n l√≥gica "or" entre False y True y mostramos el resultado
print(False or True)  # La salida ser√° True

# En esta operaci√≥n "or", al menos uno de los operandos debe ser True para que el resultado sea True.
# Como uno de los operandos es True, el resultado es True.
{{< /code >}}

{{< details summary="Ojo">}}
En Python, las comparaciones entre valores num√©ricos y valores booleanos pueden ser interesantes debido a que por ejemplo:
  ```python
  # Comparamos si 0 es igual a False y mostramos el resultado
  print(0 == False)  # La salida ser√° True
  # En Python, False se considera igual a 0 en contextos de comparaci√≥n num√©rica.

  # Comparamos si 1 es igual a True y mostramos el resultado
  print(1 == True)  # La salida ser√° True
  # Al igual que en el caso anterior, True se considera igual a 1 en contextos de comparaci√≥n num√©rica.

  # Mucho cuidado
  print(True + True)  # => 2
  print(True * 8)     # => 8
  print(False - 5)    # => -5
  print(0 == False)   # => True
  print(2 > True)     # => True
  print(2 == True)    # => False
  print(-5 != False)  # => True

  # Aplicamos la operaci√≥n l√≥gica "not" a True y mostramos el resultado
  print(not True)  # La salida ser√° False
  # La operaci√≥n "not" invierte el valor booleano. Como True se invierte a False, la salida es False.

  # Aplicamos la operaci√≥n l√≥gica "not" a False y mostramos el resultado
  print(not False)  # La salida ser√° True
  # De manera similar, la operaci√≥n "not" invierte el valor booleano. Como False se invierte a True, la salida es True
  ```
{{< /details >}}

{{< code language="python" title="Comparaci√≥n" open="false" >}}
print(5 == 5.0)       # => True   (Igualdad)
print(3 != "3")       # => True   (Desigualdad)
print(10 > 8.5)       # => True   (Mayor que)
print("a" < "b")      # => True   (Menor que - orden lexicogr√°fico)
print([1, 2] >= [1])  # => True   (Mayor o igual que - compara listas)
print(None <= None)   # => True   (Menor o igual que - None solo es igual a None)

# [1, 2] >= [1] es True porque:
# Los primeros elementos son iguales (1 == 1).
# La lista izquierda es m√°s larga (tiene un elemento extra: 2).
{{< /code >}}

## 3. Operaciones con cadenas de caracteres

{{< code language="python" title="Caracteres" open="false" >}}
# Cadenas
print("This is a string.")
print('This is also a string.')

# La forma que se utiliza para inyectar valores en cadenas
name = "jorge"
age = 33
print(f"{name} is {age} years old.")

# Slices B√°sicos [start:stop]
cad = "w3resource"
print(cad[:2] + cad[-2:])  # Primeros 2 + √∫ltimos 2: 'w3ce'
cad = "w3"
print(cad[:2] + cad[-2:])  # 'w3w3' (solapa cuando len(cad) <= 4)
cad = "w"
print(cad[:2] + cad[-2:])  # 'ww' (Python no da error con √≠ndices fuera de rango)

# Slices Complejos [start:stop:step]
cad = "w3resource"
print(cad[2:8:2])  # Desde √≠ndice 2 al 8, cada 2 caracteres: 'reo'
print(cad[::-1])  # Invierte la cadena: 'ecruoser3w'
print(cad[5:1:-1])  # Desde 5 al 1 en reversa: 'oser'
{{< /code >}}

{{< details summary="Como ocultar una tarjeta de cr√©dito menos los 4 √∫ltimos n√∫meros?">}}
  ```python
  def ocultar_tarjeta(numero):
      num_str = str(numero)
      return f"{**** **** **** {num_str[-4:]}"  # "**** **** **** 5678"

  print(ocultar_tarjeta(1234567890125678))
  ```
{{< /details >}}

## 4. Colecciones

```python
print(type([]))
print(type(()))
print(type({}))
print(type(set()))
```

{{< code language="python" title="Listas" open="false" >}}
# Tipos de estructuras vac√≠as

# üìö Caracter√≠sticas de las Listas en Python `[]`
# Mutables
# Se pueden modificar despu√©s de su creaci√≥n:
lista = [1, 2, 3]
lista[0] = 99  # [99, 2, 3]

# Ordenadas
# Conservan el orden de inserci√≥n:
[3, 1, 2] == [1, 2, 3]  # False

# Heterog√©neas
# Acepan m√∫ltiples tipos de datos:
mezcla = [1, "Python", True, 3.14, [1, 2]]

# Acceso por √≠ndices
# (`[0]`) y negativos (`[-1]`):
lista = [10, 20, 30]
print(lista[-1])  # 30

# Slicing
# Subconjuntos con `[inicio:fin:paso]`:
[1, 2, 3, 4][1:3]  # [2, 3]
[1, 2, 3, 4][::2]  # [1, 3]
[1, 2, 3, 4][::-1]  # [4, 3, 2, 1]

# Anidadas
# Pueden contener otras listas:
matriz = [[1, 2], [3, 4]]

# operaciones de listas
lista = [1, 2, 3]
lista.extend([4, 5])   # [1,2,3,4,5]
lista.insert(1, 99)    # [1,99,2,3]
lista.remove(2)        # [1,99,3]
lista.reverse()        # [3,99,1]
{{< /code >}}

{{< code language="python" title="Tuplas" open="false" >}}
# üìö Caracter√≠sticas de las Tuplas en Python `()`

## üìå Caracter√≠sticas Principales

# Inmutables
# No se pueden modificar despu√©s de su creaci√≥n:
tupla = (1, 2, 3)
# tupla[0] = 99  # Error: TypeError

# Ordenadas
# Conservan el orden de inserci√≥n:
(3, 1, 2) == (1, 2, 3)  # False

# Heterog√©neas
# Aceptan m√∫ltiples tipos de datos:
mezcla = (1, "Python", True, 3.14, [1, 2])  # S√≠ permite listas internas

# Acceso por √≠ndices
# Positivos (`[0]`) y negativos (`[-1]`):
tupla = (10, 20, 30)
print(tupla[-1])  # 30

# Slicing
# Subconjuntos con `[inicio:fin:paso]`:
(1, 2, 3, 4)[1:3]  # (2, 3)
(1, 2, 3, 4)[::2]  # (1, 3)
(1, 2, 3, 4)[::-1]  # (4, 3, 2, 1)

# Anidadas
# Pueden contener otras tuplas:
matriz = ((1, 2), (3, 4))

# Operaciones de listas
# Concatenaci√≥n
tupla1 = (1, 2)
tupla2 = (3, 4)
print(tupla1 + tupla2)  # (1, 2, 3, 4)

# Repetici√≥n
print(("a",) * 3)  # ('a', 'a', 'a')

# Longitud
print(len((1, 2, 3)))  # 3

# Contenido
print(2 in (1, 2, 3))  # True

tupla = (1, 2, 2, 3)

# count() - Cuenta ocurrencias
print(tupla.count(2))  # 2

# index() - Devuelve primera posici√≥n
print(tupla.index(3))  # 3

# Desempaquetado
a, b, c = (1, 2, 3)
print(b)  # 2
{{< /code >}}

{{< code language="python" title="Diccionarios" open="false" >}}
# üìö Caracter√≠sticas de los Diccionarios en Python `{}`

## üìå Caracter√≠sticas Principales

# Mutables
# Se pueden modificar despu√©s de su creaci√≥n:
# Como tambi√©n se pueden crear directamente:
dic = {'a': 1, 'b': 2}
dic['a'] = 99  # {'a': 99, 'b': 2}

# No ordenados (hasta Python 3.6)
# A partir de Python 3.7+ mantienen orden de inserci√≥n:
{'a': 1, 'b': 2} == {'b': 2, 'a': 1}  # False en Python 3.7+

# Claves √∫nicas
# Las claves no se pueden repetir:
dic = {'a': 1, 'a': 2}  # {'a': 2} (sobrescribe)

# ejemplo de diccionarios
dic = {'a': 1, 'b': 2}

# Acceso
print(dic['a'])  # 1
print(dic.get('c', 'default'))  # 'default' (evita KeyError)

# Agregar/Modificar
dic['c'] = 3  # {'a': 1, 'b': 2, 'c': 3}

# Eliminar
del dic['b']  # {'a': 1, 'c': 3}
valor = dic.pop('a')  # valor=1, dic={'c': 3}

# metodos importantes
dic = {'a': 1, 'b': 2}

# keys(), values(), items()
print(dic.keys())   # dict_keys(['a', 'b'])
print(dic.values()) # dict_values([1, 2])
print(dic.items())  # dict_items([('a', 1), ('b', 2)])
{{< /code >}}

{{< code language="python" title="Conjuntos" open="false" >}}
# üìö Caracter√≠sticas de los Conjuntos (Sets) en Python `{}`

## üìå Caracter√≠sticas Principales

# Mutables (set) vs Inmutables (frozenset)
mi_set = {1, 2, 3}
mi_frozenset = frozenset([1, 2, 3])

# No ordenados
print({2, 1, 3} == {1, 2, 3})  # True

# Elementos √∫nicos (no duplicados)
print({1, 1, 2})  # {1, 2}

# Hashables como elementos
valido = {1, 'a', (1, 2)}
# invalido = {[1, 2]}  # TypeError (listas no son hashables)

a = {1, 2, 3}
b = {3, 4, 5}

# Uni√≥n
print(a | b)  # {1, 2, 3, 4, 5}

# Intersecci√≥n
print(a & b)  # {3}

# Diferencia
print(a - b)  # {1, 2}

# Diferencia sim√©trica
print(a ^ b)  # {1, 2, 4, 5}

# Metodos esenciales
s = {1, 2}

# A√±adir elemento
s.add(3)  # {1, 2, 3}

# Eliminar
s.remove(2)  # {1, 3} (KeyError si no existe)
s.discard(99)  # No da error

# Pop (elimina aleatorio)
elem = s.pop()

# Limpiar
s.clear()  # set()
{{< /code >}}

## 5. Control de flujo

## 6. Funciones

## 7. Alcance de las variables

{{< code language="python" title="Scope de la variable x" open="false" >}}
# Alcance de Variables

# Definimos una variable global 'x' con el valor 5.
x = 5

# Creamos una funci√≥n 'set_x' que toma un argumento 'num'.
def set_x(num):
    # Dentro de la funci√≥n, creamos una nueva variable local 'x' con el valor 'num'.
    x = num
    # Imprimimos el valor de 'x' dentro de la funci√≥n 'set_x'.
    print("Dentro de set_x:", x)

# Creamos una funci√≥n 'set_global_x' que toma un argumento 'num'.
def set_global_x(num):
    # Utilizamos la palabra clave 'global' para indicar que estamos modificando la variable global 'x'.
    global x
    # Imprimimos el valor de la variable global 'x' antes de cambiarlo.
    print("Antes de set_global_x:", x)
    # Asignamos el valor 'num' a la variable global 'x'.
    x = num
    # Imprimimos el nuevo valor de la variable global 'x'.
    print("Despu√©s de set_global_x:", x)

# Imprimimos el valor de la variable global 'x' antes de llamar a las funciones.
print("Valor de x antes de las funciones:", x)

# Llamamos a las funciones 'set_x' y 'set_global_x' con diferentes valores.
set_x(43)  # Esto crea una variable local 'x' con el valor 43 y la imprime.
set_global_x(6)  # Esto modifica la variable global 'x' y la imprime.

# Imprimimos el valor de la variable global 'x' despu√©s de llamar a las funciones.
print("Valor de x despu√©s de las funciones:", x)
{{< /code >}}

{{< details summary="Colecciones o estructuras de datos">}}
  ```python
  ```
{{< /details >}}


## 8. OPP

{{< code language="python" title="Class Dog" open="false" >}}
from abc import ABC, abstractmethod, ClassVar

# Abstracci√≥n: Definir interfaces y ocultar detalles complejos
class Animal(ABC):  # Clase abstracta
    @abstractmethod
    def make_sound(self) -> str:
        pass

# Encapsulamiento: Ocultar detalles internos y proveer interfaz controlada
# Herencia de la clase Animal
class Dog(Animal):
    """A class representing a dog with basic attributes and behaviors."""

    species: ClassVar[str] = 'mammal'
    total_dogs = 0  # Variable de clase para rastrear todos los perros creados

    def __init__(self, name: str, age: int) -> None:
        if not name:
            raise ValueError("Name cannot be empty")
        if age <= 0:
            raise ValueError("Age must be positive")

        # Atributos "protegidos" (por convenci√≥n con _)
        self._name: str = name
        self._age: int = age
        Dog.total_dogs += 1  # Incrementa el contador al crear una nueva instancia

        publico = 1      # P√∫blico
        _protegido = 2   # Protegido (por convenci√≥n)
        __privado = 3    # "Privado" (name mangling)

    @property
    def description(self) -> str:
        """Return a formatted string with the dog's name and age."""
        return f"{self._name} is {self._age} years old"

    def speak(self, sound: str) -> str:
        return f"{self._name} says {sound.lower()}"

    def have_birthday(self) -> None:
        """Increment the dog's age by 1 year."""
        self._age += 1
        print(f"Happy birthday {self._name}! Now {self.description}")

    @staticmethod
    def dog_years_to_human(years: int) -> float:
        return years * 4

    @classmethod
    def from_birth_year(cls, name: str, birth_year: int) -> 'Dog':
        current_year = 2023  # Podr√≠a obtenerse de datetime.now().year
        age = current_year - birth_year
        return cls(name, age)  # cls se refiere a la clase misma crea una nueva instancia (Dog)

    @classmethod
    def get_total_dogs(cls) -> int:
        """M√©todo de clase para obtener el total de perros creados."""
        return cls.total_dogs

    # M√©todos para obtener y modificar los atributos privados
    def get_name(self):
        return self.__name

    def get_age(self):
        return self.__age

    def set_name(self, name):
        self.__name = name

    def set_age(self, age):
        self.__age = age

# polimorfismo se ve mejor cuando tenemos m√∫ltiples clases no relacionadas por herencia pero que comparten la misma interfaz.
class Cat(Animal):
    def __init__(self, name: str):
        self.name = name

    def make_sound(self) -> str:
        return "Meow!"

# Acceso:
e = Ejemplo()
print(e.publico)        # ‚úÖ 1
print(e._protegido)     # ‚ö†Ô∏è 2 (accesible pero no recomendado)
# print(e.__privado)    # ‚ùå Error
print(e._Ejemplo__privado)  # ‚ö†Ô∏è 3 (acceso forzado - evitar
{{< /code >}}

{{< details summary="Que es el ABC">}}
Es una clase especial del m√≥dulo abc que permite crear clases abstractas:
- No se puede instanciar directamente: Solo sirve como plantilla.
- Obliga a implementar m√©todos: Define un "contrato" que las subclases deben cumplir.
{{< /details >}}

## 9. ERRORES

{{< code language="python" title="Errores" open="false" >}}
# Esto causar√° un error de sintaxis.
print( 0 / 0 ))

# Cell In[14], line 2
#    print( 0 / 0 ))
                  ^
# SyntaxError: unmatched ')'

# Esto causar√° un error de divisi√≥n por cero, pero la sintaxis ser√° correcta.
print( 0 / 0)

# ---------------------------------------------------------------------------
# ZeroDivisionError                         Traceback (most recent call last)
# Cell In[15], line 2
#      1 # Esto causar√° un error de divisi√≥n por cero, pero la sintaxis ser√° correcta.
# ----> 2 print( 0 / 0)

# ZeroDivisionError: division by zero

# Asignamos un valor a la variable x.
x = 10

# Comprobamos si x es mayor que 5.
if x > 5:
    # Si x es mayor que 5, levantamos una excepci√≥n con un mensaje personalizado.
    raise Exception(f'x should not exceed 5. The value of x was: {x}')

# Bloque try-except b√°sico (except se ejecuta si hay errores)
try:
    # C√≥digo que puede fallar
    archivo = open("inexistente.txt")
except Exception as e:
    print(f"Ocurri√≥ un error: {e}")

# Bloque try-except con m√∫ltiples excepciones
try:
    # C√≥digo que puede fallar
    archivo = open("inexistente.txt")
except FileNotFoundError as e:
    print(f"Archivo no encontrado: {e}")
except PermissionError as e:
    print(f"Permiso denegado: {e}")
except Exception as e:
    print(f"Ocurri√≥ un error: {e}")

# Bloque else (se ejecuta si no hay errores)
try:
    # print("Intentando abrir el archivo")
    archivo = open("datos.txt", "r")  # Modo lectura
    contenido = archivo.read()
except Exception as e:
    print(f"Ocurri√≥ un error: {e}")
else:
    # print("Archivo le√≠do correctamente")
    print(f"Contenido: {contenido}")


# Bloque try-except-finally
try:
    # C√≥digo que puede fallar
    archivo = open("datos.txt", "r")  # Modo lectura
    contenido = archivo.read()
except Exception as e:
    print(f"Ocurri√≥ un error: {e}")
else:
    # print("Archivo le√≠do correctamente")
    print(f"Contenido: {contenido}")
finally:
    # Cerrar el archivo, independientemente de si hubo errores o no
    archivo.close()

{{< /code >}}
